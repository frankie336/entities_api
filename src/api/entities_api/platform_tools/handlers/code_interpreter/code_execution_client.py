import asyncio
import json
import os
from dataclasses import dataclass
from typing import Any, AsyncGenerator, Dict, Generator, Optional

import websockets
from dotenv import load_dotenv
from projectdavid_common.utilities.logging_service import LoggingUtility
from tenacity import retry, retry_if_exception_type, stop_after_attempt, wait_fixed
from websockets.legacy.protocol import WebSocketCommonProtocol

load_dotenv()
logging_utility = LoggingUtility()


@dataclass
class ExecutionClientConfig:
    endpoint: str = os.getenv("CODE_EXECUTION_URL", "ws://localhost:8001/execute")
    timeout: float = 15.0
    retries: int = 3
    retry_delay: float = 2.0


class CodeExecutionClientError(Exception):
    pass


class ExecutionTimeoutError(CodeExecutionClientError):
    pass


class ExecutionSecurityViolation(CodeExecutionClientError):
    pass


class CodeExecutionClient:
    def __init__(self, token: str, config: Optional[ExecutionClientConfig] = None):
        """
        :param token: The JWT generated by the Main API.
        :param config: Connection configuration.
        """
        self.config = config or ExecutionClientConfig()
        self.token = token
        self._connection: Optional[WebSocketCommonProtocol] = None

        # Ensure endpoint doesn't end with /
        if self.config.endpoint.endswith("/"):
            self.config.endpoint = self.config.endpoint[:-1]

    async def __aenter__(self):
        await self.connect()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.close()

    @retry(
        stop=stop_after_attempt(3),
        wait=wait_fixed(2.0),
        retry=retry_if_exception_type((OSError, ConnectionRefusedError)),
    )
    async def connect(self):
        try:
            # ✅ Construct URL with Token
            # If endpoint is "ws://host/execute", result is "ws://host/execute?token=ey..."
            auth_url = f"{self.config.endpoint}?token={self.token}"

            logging_utility.info(
                "Attempting to connect to WebSocket endpoint: %s", self.config.endpoint
            )

            self._connection = await asyncio.wait_for(
                websockets.connect(auth_url, ping_interval=None),
                timeout=self.config.timeout,
            )
            logging_utility.info("Successfully connected to WebSocket endpoint.")
        except asyncio.TimeoutError as e:
            logging_utility.error("Connection to %s timed out", self.config.endpoint)
            raise ExecutionTimeoutError(
                f"Connection to {self.config.endpoint} timed out"
            ) from e
        except websockets.exceptions.InvalidStatusCode as e:
            # Handle 403/1008 errors specifically
            if e.status_code == 403 or e.status_code == 1008:
                logging_utility.error("Authentication failed: %s", str(e))
                raise ExecutionSecurityViolation(
                    "Sandbox rejected authentication token"
                )
            raise e

    async def close(self):
        if self._connection:
            logging_utility.info("Closing WebSocket connection.")
            await self._connection.close()
            self._connection = None

    async def execute_code(
        self, code: str, **metadata: Dict[str, Any]
    ) -> AsyncGenerator[str, None]:
        if not self._connection:
            raise CodeExecutionClientError("Not connected to execution endpoint")
        try:
            # We don't need to send user_id here anymore; the Token handled identity
            await self._connection.send(
                json.dumps({"code": code, "metadata": metadata})
            )

            while True:
                message = await self._connection.recv()
                if not message:
                    continue
                try:
                    data = json.loads(message)
                    # ... [Rest of your existing processing logic remains exactly the same] ...
                    if isinstance(data, dict):
                        if "error" in data:
                            logging_utility.error("Execution Error: %s", data["error"])
                            # If it's a security error from inside the logic
                            if "Security" in data["error"]:
                                raise ExecutionSecurityViolation(data["error"])
                            yield json.dumps(
                                {"type": "error", "content": data["error"]}
                            )
                        elif "status" in data and "uploaded_files" in data:
                            yield json.dumps(
                                {
                                    "type": "status",
                                    "content": data["status"],
                                    "execution_id": data.get("execution_id"),
                                    "uploaded_files": data.get("uploaded_files", []),
                                }
                            )
                            break
                        elif "status" in data:
                            yield json.dumps(
                                {"type": "status", "content": data["status"]}
                            )
                        elif "output" in data:
                            yield json.dumps(
                                {"type": "output", "content": data["output"]}
                            )
                        else:
                            yield json.dumps(
                                {"type": "hot_code_output", "content": str(data)}
                            )
                    else:
                        yield json.dumps(
                            {"type": "hot_code_output", "content": str(data)}
                        )
                except json.JSONDecodeError:
                    yield json.dumps({"type": "hot_code_output", "content": message})

        except websockets.exceptions.ConnectionClosed:
            logging_utility.error("WebSocket connection closed unexpectedly.")
            raise CodeExecutionClientError("Connection closed unexpectedly")


class StreamOutput:
    def __init__(self) -> None:
        pass

    def stream_output(self, code: str, token: str) -> Generator[str, None, None]:
        """
        Synchronous generator bridge.
        ✅ NOW ACCEPTS TOKEN
        """
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)

        async def _async_wrapper() -> AsyncGenerator[str, None]:
            # ✅ Pass token to Client
            async with CodeExecutionClient(token=token) as client:
                async for chunk in client.execute_code(code):
                    yield chunk

        async_gen = _async_wrapper()

        try:
            while True:
                try:
                    chunk = loop.run_until_complete(async_gen.__anext__())
                    yield chunk
                except StopAsyncIteration:
                    break
        except Exception as e:
            logging_utility.error(f"StreamOutput Bridge Error: {e}")
            raise e
        finally:
            try:
                pending = asyncio.all_tasks(loop)
                for task in pending:
                    task.cancel()
                if pending:
                    loop.run_until_complete(
                        asyncio.gather(*pending, return_exceptions=True)
                    )
                loop.close()
            except Exception:
                pass
            finally:
                asyncio.set_event_loop(None)
